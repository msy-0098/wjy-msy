<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>💗 Love you 💗 My Dear WJY💗</title>
    <style type="text/css">
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            display: block;
        }
        #pinkboard {
            animation: anim 1.5s ease-in-out infinite;
        }
        @keyframes anim {
            0%, 100% { transform: scale(0.8); }
            25%, 75% { transform: scale(0.7); }
            50% { transform: scale(1); }
        }
        #name {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin-top: -20px;
            font-size: clamp(24px, 5vw, 46px);
            color: #ea80b0;
            pointer-events: none;
        }
    </style>
</head>
<body>
<canvas id="pinkboard"></canvas>
<canvas id="canvas"></canvas>

<script type="text/javascript">
    // 性能优化：使用常量和缓存
    const loverName = "WJY";
    const colors = [
        "#eec996", "#8fb7d3", "#b7d4c6", "#c3bedd", "#f1d5e4", 
        "#cae1d3", "#f3c89d", "#d0b0c3", "#819d53", "#c99294", 
        "#cec884", "#ff8e70", "#e0a111", "#fffdf6", "#cbd7ac", 
        "#e8c6c0", "#dc9898", "#ecc8ba"
    ];
    const COLOR_COUNT = colors.length;
    
    // 获取画布和上下文
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let hearts = [];
    let ww, wh;
    let lastTime = 0;
    const MAX_HEARTS = 100;
    
    // 初始化尺寸
    function resizeCanvas() {
        ww = window.innerWidth;
        wh = window.innerHeight;
        canvas.width = ww;
        canvas.height = wh;
    }
    
    // 心形文字类
    class Heart {
        constructor() {
            this.reset();
        }
        
        reset() {
            this.x = Math.random() * ww;
            this.y = Math.random() * wh;
            this.opacity = Math.random() * 0.5 + 0.5;
            this.vel = {
                x: (Math.random() - 0.5) * 4,
                y: (Math.random() - 0.5) * 4
            };
            this.targetScale = Math.random() * 0.15 + 0.02;
            this.scale = this.targetScale * Math.random();
            this.width = 473.8;
            this.height = 408.6;
        }
        
        update(deltaTime) {
            this.x += this.vel.x * deltaTime * 60; // 基于时间的动画
            this.y += this.vel.y * deltaTime * 60;
            this.scale += (this.targetScale - this.scale) * 0.01 * (deltaTime * 60);
            
            // 边界检查，超出屏幕则重置
            if (this.x - this.width > ww || this.x + this.width < 0 ||
                this.y - this.height > wh || this.y + this.height < 0) {
                this.reset();
            }
        }
        
        draw(index) {
            ctx.globalAlpha = this.opacity;
            ctx.font = `${180 * this.scale}px "宋体"`;
            ctx.fillStyle = colors[index % COLOR_COUNT];
            ctx.fillText(
                loverName,
                this.x - this.width * 0.5,
                this.y - this.height * 0.5,
                this.width,
                this.height
            );
        }
    }
    
    // 渲染函数 - 使用时间戳控制动画速度
    function render(timestamp) {
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        
        ctx.clearRect(0, 0, ww, wh);
        
        for (let i = 0; i < MAX_HEARTS; i++) {
            hearts[i].update(deltaTime);
            hearts[i].draw(i);
        }
        
        requestAnimationFrame(render);
    }
    
    // 初始化
    function init() {
        resizeCanvas();
        // 预创建心形对象池
        for (let i = 0; i < MAX_HEARTS; i++) {
            hearts.push(new Heart());
        }
        requestAnimationFrame(render);
    }
    
    // 监听窗口大小变化
    window.addEventListener("resize", resizeCanvas);
    
    // 启动
    init();
</script>

<script>
    /* 粒子效果优化版 */
    const settings = {
        particles: {
            length: 300, // 适当减少粒子数量提升性能
            duration: 2,
            velocity: 100,
            effect: -0.75,
            size: 30,
        },
    };

    /* RequestAnimationFrame polyfill */
    (function() {
        let lastTime = 0;
        const vendors = ['ms', 'moz', 'webkit', 'o'];
        for(let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
                || window[vendors[x]+'CancelRequestAnimationFrame'];
        }

        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback) {
                const currTime = new Date().getTime();
                const timeToCall = Math.max(0, 16 - (currTime - lastTime));
                const id = window.setTimeout(() => callback(currTime + timeToCall), timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }

        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
        }
    })();

    /* 点类 */
    class Point {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        
        clone() {
            return new Point(this.x, this.y);
        }
        
        length(length) {
            if (typeof length === 'undefined') {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
            this.normalize();
            this.x *= length;
            this.y *= length;
            return this;
        }
        
        normalize() {
            const length = this.length();
            this.x /= length;
            this.y /= length;
            return this;
        }
    }

    /* 粒子类 */
    class Particle {
        constructor() {
            this.position = new Point();
            this.velocity = new Point();
            this.acceleration = new Point();
            this.age = 0;
        }
        
        initialize(x, y, dx, dy) {
            this.position.x = x;
            this.position.y = y;
            this.velocity.x = dx;
            this.velocity.y = dy;
            this.acceleration.x = dx * settings.particles.effect;
            this.acceleration.y = dy * settings.particles.effect;
            this.age = 0;
        }
        
        update(deltaTime) {
            this.position.x += this.velocity.x * deltaTime;
            this.position.y += this.velocity.y * deltaTime;
            this.velocity.x += this.acceleration.x * deltaTime;
            this.velocity.y += this.acceleration.y * deltaTime;
            this.age += deltaTime;
        }
        
        draw(context, image) {
            // 缓动函数缓存
            const ease = (t) => --t * t * t + 1;
            const size = image.width * ease(this.age / settings.particles.duration);
            
            context.globalAlpha = 1 - this.age / settings.particles.duration;
            context.drawImage(
                image,
                this.position.x - size / 2,
                this.position.y - size / 2,
                size,
                size
            );
        }
    }

    /* 粒子池类 - 对象池模式减少GC */
    class ParticlePool {
        constructor(length) {
            this.particles = new Array(length);
            for (let i = 0; i < this.particles.length; i++) {
                this.particles[i] = new Particle();
            }
            this.firstActive = 0;
            this.firstFree = 0;
            this.duration = settings.particles.duration;
        }
        
        add(x, y, dx, dy) {
            this.particles[this.firstFree].initialize(x, y, dx, dy);
            
            // 循环队列处理
            this.firstFree++;
            if (this.firstFree === this.particles.length) this.firstFree = 0;
            if (this.firstActive === this.firstFree) this.firstActive++;
            if (this.firstActive === this.particles.length) this.firstActive = 0;
        }
        
        update(deltaTime) {
            if (this.firstActive < this.firstFree) {
                for (let i = this.firstActive; i < this.firstFree; i++) {
                    this.particles[i].update(deltaTime);
                }
            } else if (this.firstFree < this.firstActive) {
                for (let i = this.firstActive; i < this.particles.length; i++) {
                    this.particles[i].update(deltaTime);
                }
                for (let i = 0; i < this.firstFree; i++) {
                    this.particles[i].update(deltaTime);
                }
            }
            
            // 移除 inactive 粒子
            while (this.particles[this.firstActive].age >= this.duration && 
                   this.firstActive !== this.firstFree) {
                this.firstActive++;
                if (this.firstActive === this.particles.length) this.firstActive = 0;
            }
        }
        
        draw(context, image) {
            if (this.firstActive < this.firstFree) {
                for (let i = this.firstActive; i < this.firstFree; i++) {
                    this.particles[i].draw(context, image);
                }
            } else if (this.firstFree < this.firstActive) {
                for (let i = this.firstActive; i < this.particles.length; i++) {
                    this.particles[i].draw(context, image);
                }
                for (let i = 0; i < this.firstFree; i++) {
                    this.particles[i].draw(context, image);
                }
            }
        }
    }

    /* 初始化粒子效果 */
    (function(canvas) {
        const context = canvas.getContext("2d");
        const particles = new ParticlePool(settings.particles.length);
        const particleRate = settings.particles.length / settings.particles.duration;
        let time;
        
        // 心形路径计算
        function pointOnHeart(t) {
            return new Point(
                160 * Math.pow(Math.sin(t), 3),
                130 * Math.cos(t) - 50 * Math.cos(2 * t) - 
                20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
            );
        }
        
        // 创建粒子图像
        const image = (function() {
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            canvas.width = settings.particles.size;
            canvas.height = settings.particles.size;
            
            function to(t) {
                const point = pointOnHeart(t);
                point.x = settings.particles.size / 2 + (point.x * settings.particles.size) / 350;
                point.y = settings.particles.size / 2 - (point.y * settings.particles.size) / 350;
                return point;
            }
            
            context.beginPath();
            let t = -Math.PI;
            let point = to(t);
            context.moveTo(point.x, point.y);
            
            while (t < Math.PI) {
                t += 0.01;
                point = to(t);
                context.lineTo(point.x, point.y);
            }
            
            context.closePath();
            context.fillStyle = "#ea80b0";
            context.fill();
            
            const image = new Image();
            image.src = canvas.toDataURL();
            return image;
        })();
        
        // 渲染函数
        function render(timestamp) {
            requestAnimationFrame(render);
            
            const newTime = timestamp / 1000;
            const deltaTime = newTime - (time || newTime);
            time = newTime;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // 基于时间创建新粒子
            const amount = particleRate * deltaTime;
            for (let i = 0; i < amount; i++) {
                const pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
                const dir = pos.clone().length(settings.particles.velocity);
                particles.add(
                    canvas.width / 2 + pos.x,
                    canvas.height / 2 - pos.y,
                    dir.x,
                    -dir.y
                );
            }
            
            particles.update(deltaTime);
            particles.draw(context, image);
        }
        
        // 处理尺寸调整
        function onResize() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        }
        
        window.addEventListener("resize", onResize);
        
        // 启动
        setTimeout(() => {
            onResize();
            render(0);
        }, 10);
    })(document.getElementById("pinkboard"));
</script>
</body>
</html>
